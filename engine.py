"""
engine.py v7 â€” ë°°í•©ê³„ì‚° + AIí˜ë¥´ì†Œë‚˜ + HACCPì„œë¥˜ + ì‹í’ˆí‘œì‹œê¸°ì¤€
"""
import pandas as pd
import numpy as np
import json, re, math
from datetime import datetime

# ============================================================
# 1. ìŠ¬ë¡¯ ì‹œìŠ¤í…œ
# ============================================================
SLOT_GROUPS = [
    ("ì›ì¬ë£Œ", list(range(1, 5))),
    ("ë‹¹ë¥˜/ê°ë¯¸ë£Œ", list(range(5, 9))),
    ("ì•ˆì •ì œ/í˜¸ë£Œ", list(range(9, 13))),
    ("ê¸°íƒ€ìì¬", list(range(13, 20))),
    ("ì •ì œìˆ˜", [20]),
]

EMPTY_SLOT = {
    'ì›ë£Œëª…': '', 'ë°°í•©ë¹„(%)': 0.0,
    'AIì¶”ì²œ_ì›ë£Œëª…': '', 'AIì¶”ì²œ_%': 0.0,
    'AIìš©ë„íŠ¹ì„±': '',
    'ë‹¹ë„(Bx)': 0, 'ì‚°ë„(%)': 0, 'ê°ë¯¸ë„': 0, 'ê¸°ëŠ¥1': '', 'ê¸°ëŠ¥2': '',
    'ë‹¨ê°€(ì›/kg)': 0, 'pH': 0, 'Brix(Â°)': 0, 'ê°ë¯¸ë„(ì„¤íƒ•ëŒ€ë¹„)': 0,
    '1%Brixê¸°ì—¬': 0, '1%pHì˜í–¥': 0, '1%ì‚°ë„ê¸°ì—¬': 0, '1%ê°ë¯¸ê¸°ì—¬': 0,
    'ë‹¹ê¸°ì—¬': 0, 'ì‚°ê¸°ì—¬': 0, 'ê°ë¯¸ê¸°ì—¬': 0, 'ë‹¨ê°€ê¸°ì—¬(ì›/kg)': 0, 'ë°°í•©ëŸ‰(g/kg)': 0,
    'is_custom': False,
}


def init_slots():
    return [EMPTY_SLOT.copy() for _ in range(20)]


def fill_slot_from_db(slot, name, df_ing, ph_col):
    row = df_ing[df_ing['ì›ë£Œëª…'] == name]
    if row.empty:
        return slot
    r = row.iloc[0]
    slot['ì›ë£Œëª…'] = name
    slot['ë‹¹ë„(Bx)'] = safe_float(r.get('Brix(Â°)', 0))
    slot['ì‚°ë„(%)'] = safe_float(r.get('ì‚°ë„(%)', 0))
    slot['ê°ë¯¸ë„'] = safe_float(r.get('ê°ë¯¸ë„(ì„¤íƒ•ëŒ€ë¹„)', 0))
    slot['ë‹¨ê°€(ì›/kg)'] = safe_float(r.get('ì˜ˆìƒë‹¨ê°€(ì›/kg)', 0))
    slot['pH'] = safe_float(r.get('pH', 0))
    slot['Brix(Â°)'] = safe_float(r.get('Brix(Â°)', 0))
    slot['ê°ë¯¸ë„(ì„¤íƒ•ëŒ€ë¹„)'] = safe_float(r.get('ê°ë¯¸ë„(ì„¤íƒ•ëŒ€ë¹„)', 0))
    slot['1%Brixê¸°ì—¬'] = safe_float(r.get('1%ì‚¬ìš©ì‹œ Brixê¸°ì—¬(Â°)', 0))
    slot['1%pHì˜í–¥'] = safe_float(r.get(ph_col, 0))
    slot['1%ì‚°ë„ê¸°ì—¬'] = safe_float(r.get('1%ì‚¬ìš©ì‹œ ì‚°ë„ê¸°ì—¬(%)', 0))
    slot['1%ê°ë¯¸ê¸°ì—¬'] = safe_float(r.get('1%ì‚¬ìš©ì‹œ ê°ë¯¸ê¸°ì—¬', 0))
    slot['is_custom'] = False
    return slot


def safe_float(v, default=0):
    try:
        f = float(v)
        return f if not math.isnan(f) else default
    except:
        return default


def calc_slot_contributions(slot):
    pct = safe_float(slot.get('ë°°í•©ë¹„(%)', 0))
    if pct <= 0:
        for k in ['ë‹¹ê¸°ì—¬', 'ì‚°ê¸°ì—¬', 'ê°ë¯¸ê¸°ì—¬', 'ë‹¨ê°€ê¸°ì—¬(ì›/kg)', 'ë°°í•©ëŸ‰(g/kg)']:
            slot[k] = 0
        return slot
    slot['ë‹¹ê¸°ì—¬'] = round(safe_float(slot.get('1%Brixê¸°ì—¬', 0)) * pct, 2)
    slot['ì‚°ê¸°ì—¬'] = round(safe_float(slot.get('1%ì‚°ë„ê¸°ì—¬', 0)) * pct, 4)
    slot['ê°ë¯¸ê¸°ì—¬'] = round(safe_float(slot.get('1%ê°ë¯¸ê¸°ì—¬', 0)) * pct, 4)
    slot['ë‹¨ê°€ê¸°ì—¬(ì›/kg)'] = round(safe_float(slot.get('ë‹¨ê°€(ì›/kg)', 0)) * pct / 100, 1)
    slot['ë°°í•©ëŸ‰(g/kg)'] = round(pct * 10, 1)
    return slot


def calc_formulation(slots, volume_ml=500):
    total_brix = sum(safe_float(s.get('ë‹¹ê¸°ì—¬', 0)) for s in slots)
    total_acid = sum(safe_float(s.get('ì‚°ê¸°ì—¬', 0)) for s in slots)
    total_sweet = sum(safe_float(s.get('ê°ë¯¸ê¸°ì—¬', 0)) for s in slots)
    total_dph = sum(safe_float(s.get('1%pHì˜í–¥', 0)) * safe_float(s.get('ë°°í•©ë¹„(%)', 0)) for s in slots)
    total_cost_kg = sum(safe_float(s.get('ë‹¨ê°€ê¸°ì—¬(ì›/kg)', 0)) for s in slots)
    ing_pct = sum(safe_float(s.get('ë°°í•©ë¹„(%)', 0)) for s in slots[:19])
    water_pct = round(max(0, 100 - ing_pct), 3)

    slots[19]['ì›ë£Œëª…'] = 'ì •ì œìˆ˜'
    slots[19]['ë°°í•©ë¹„(%)'] = water_pct
    slots[19]['ë°°í•©ëŸ‰(g/kg)'] = round(water_pct * 10, 1)

    juice_pct = 0
    for s in slots[:4]:
        p = safe_float(s.get('ë°°í•©ë¹„(%)', 0))
        if p > 0 and ('ë†ì¶•' in str(s.get('ì›ë£Œëª…', '')) or 'ê³¼ì¦™' in str(s.get('ì›ë£Œëª…', ''))):
            bx = safe_float(s.get('Brix(Â°)', 0))
            juice_pct += p * (bx / 11.5 if bx >= 40 else 1)

    return {
        'ë°°í•©ë¹„í•©ê³„(%)': round(ing_pct + water_pct, 3),
        'ì˜ˆìƒë‹¹ë„(Bx)': round(total_brix, 2),
        'ì˜ˆìƒpH': round(3.5 + total_dph, 2),
        'ì˜ˆìƒì‚°ë„(%)': round(total_acid, 4),
        'ì˜ˆìƒê°ë¯¸ë„': round(total_sweet, 4),
        'ë‹¹ì‚°ë¹„': round(total_brix / total_acid, 1) if total_acid > 0 else 0,
        'ì›ì¬ë£Œë¹„(ì›/kg)': round(total_cost_kg, 1),
        'ì›ì¬ë£Œë¹„(ì›/ë³‘)': round(total_cost_kg * volume_ml / 1000, 1),
        'ì›ë£Œì¢…ë¥˜(ê°œ)': sum(1 for s in slots[:19] if safe_float(s.get('ë°°í•©ë¹„(%)', 0)) > 0),
        'ì •ì œìˆ˜ë¹„ìœ¨(%)': round(water_pct, 1),
        'ê³¼ì¦™í•¨ëŸ‰(%)': round(juice_pct, 1),
    }


# ============================================================
# 2. ê·œê²© íŒì •
# ============================================================
def get_spec(df_spec, bev_type):
    row = df_spec[df_spec['ìŒë£Œìœ í˜•'].str.contains(bev_type.split('(')[0], na=False)]
    if row.empty:
        return None
    r = row.iloc[0]
    return {k: safe_float(r.get(k, 0)) for k in ['Brix_min', 'Brix_max', 'pH_min', 'pH_max', 'ì‚°ë„_min', 'ì‚°ë„_max']}


def check_compliance(result, spec):
    if not spec:
        return {}
    checks = {}
    bx = result['ì˜ˆìƒë‹¹ë„(Bx)']
    bmin, bmax = spec.get('Brix_min', 0), spec.get('Brix_max', 99)
    if bmin <= bx <= bmax:
        checks['ë‹¹ë„'] = (f'âœ… ê·œê²©ì´ë‚´({bmin}~{bmax}Â°)', True)
    else:
        checks['ë‹¹ë„'] = (f'âš ï¸ ê·œê²©ì´íƒˆ({bx:.2f}Â° â†’ ê¸°ì¤€ {bmin}~{bmax}Â°)', False)

    ac = result['ì˜ˆìƒì‚°ë„(%)']
    amin, amax = spec.get('ì‚°ë„_min', 0), spec.get('ì‚°ë„_max', 0)
    if amin > 0 or amax > 0:
        if amin <= ac <= amax:
            checks['ì‚°ë„'] = (f'âœ… ê·œê²©ì´ë‚´({amin}~{amax}%)', True)
        else:
            checks['ì‚°ë„'] = (f'âš ï¸ ê·œê²©ì´íƒˆ({ac:.4f}% â†’ ê¸°ì¤€ {amin}~{amax}%)', False)

    checks['ì›ì¬ë£Œë¹„'] = ('âœ… ëª©í‘œì´ë‚´', True)
    wp = result['ì •ì œìˆ˜ë¹„ìœ¨(%)']
    checks['ì •ì œìˆ˜ë¹„ìœ¨'] = ('âœ… ì ì •(50%ì´ìƒ)', True) if wp >= 50 else ('âš ï¸ 50% ë¯¸ë§Œ', False)

    phmin, phmax = spec.get('pH_min', 0), spec.get('pH_max', 0)
    if phmin > 0:
        checks['pH'] = (f'â„¹ï¸ pHê·œê²©: {phmin}~{phmax} â†’ ì‹¤ì¸¡ í•„ìš”', None)
    return checks


# ============================================================
# 3. ê°€ì´ë“œë°°í•©ë¹„ ë¡œë”©
# ============================================================
def load_guide(df_guide, bev_type, flavor, df_ing, ph_col):
    bt = bev_type.split('(')[0]  # ê³¼Â·ì±„ìŒë£Œ ìœ ì§€
    key_prefix = f"{bt}_{flavor}_" if flavor else ""
    if not key_prefix:
        return init_slots()
    rows = df_guide[df_guide['í‚¤(ìœ í˜•_ë§›_ìŠ¬ë¡¯)'].str.startswith(key_prefix, na=False)].sort_values('ìŠ¬ë¡¯ë²ˆí˜¸')
    slots = init_slots()
    for _, r in rows.iterrows():
        idx = int(r['ìŠ¬ë¡¯ë²ˆí˜¸']) - 1
        if idx < 0 or idx >= 19:
            continue
        ai_name = r.get('AIì¶”ì²œ_ì›ë£Œëª…')
        ai_pct = r.get('AIì¶”ì²œ_ë°°í•©ë¹„(%)')
        if pd.notna(ai_name) and str(ai_name).strip():
            slots[idx] = fill_slot_from_db(slots[idx], str(ai_name), df_ing, ph_col)
            if pd.notna(ai_pct) and safe_float(ai_pct) > 0:
                slots[idx]['ë°°í•©ë¹„(%)'] = safe_float(ai_pct)
            slots[idx]['AIì¶”ì²œ_ì›ë£Œëª…'] = str(ai_name) if pd.notna(ai_name) else ''
            slots[idx]['AIì¶”ì²œ_%'] = safe_float(ai_pct)
        slots[idx] = calc_slot_contributions(slots[idx])
    return slots


# ============================================================
# 4. ì—­ì„¤ê³„
# ============================================================
def reverse_engineer(prod_row, df_ing, ph_col):
    slots = init_slots()
    idx = 0
    for i in range(1, 8):
        col = f'ë°°í•©ìˆœìœ„{i}' if i > 1 else 'ë°°í•©ìˆœìœ„1(ì›ì¬ë£Œ/ë°°í•©ë¹„%/ì›ì‚°ì§€)'
        val = prod_row.get(col)
        if pd.isna(val) or str(val).strip() in ['â€”', '-', '0', '']:
            continue
        parts = str(val).split('/')
        name = parts[0].strip()
        pct = safe_float(parts[1].replace('%', '') if len(parts) > 1 else 0)
        matched = df_ing[df_ing['ì›ë£Œëª…'].str.contains(name.split('(')[0][:4], na=False)]
        if not matched.empty:
            slots[idx] = fill_slot_from_db(slots[idx], matched.iloc[0]['ì›ë£Œëª…'], df_ing, ph_col)
        else:
            slots[idx]['ì›ë£Œëª…'] = name
            slots[idx]['is_custom'] = True
        slots[idx]['ë°°í•©ë¹„(%)'] = pct
        slots[idx] = calc_slot_contributions(slots[idx])
        idx += 1
        if idx >= 19:
            break
    return slots


# ============================================================
# 5. ì‹í’ˆí‘œì‹œì‚¬í•­ (ì‹í’ˆë“±ì˜ í‘œì‹œê¸°ì¤€ ë°˜ì˜)
# ============================================================
ALLERGENS = ['ë‚œë¥˜(ê°€ê¸ˆë¥˜)', 'ìš°ìœ ', 'ë©”ë°€', 'ë•…ì½©', 'ëŒ€ë‘', 'ë°€', 'ê³ ë“±ì–´', 'ê²Œ', 'ìƒˆìš°',
             'ë¼ì§€ê³ ê¸°', 'ë³µìˆ­ì•„', 'í† ë§ˆí† ', 'í˜¸ë‘', 'ë‹­ê³ ê¸°', 'ì‡ ê³ ê¸°', 'ì˜¤ì§•ì–´',
             'ì¡°ê°œë¥˜(êµ´,ì „ë³µ,í™í•©)', 'ì£', 'ì•„í™©ì‚°ë¥˜']

ALLERGEN_KEYWORDS = {
    'ë‚œë¥˜(ê°€ê¸ˆë¥˜)': ['ê³„ë€', 'ë‚œë°±', 'ë‚œí™©', 'ì•Œ', 'egg'],
    'ìš°ìœ ': ['ìš°ìœ ', 'ìœ ì²­', 'íƒˆì§€ë¶„ìœ ', 'ì „ì§€ë¶„ìœ ', 'ì¹´ì œì¸', 'milk', 'í¬ë¦¼'],
    'ëŒ€ë‘': ['ëŒ€ë‘', 'ì½©', 'ë‘ìœ ', 'soy'],
    'ë°€': ['ë°€', 'ì†Œë§¥', 'ê¸€ë£¨í…', 'wheat'],
    'ë³µìˆ­ì•„': ['ë³µìˆ­ì•„', 'peach'],
    'í† ë§ˆí† ': ['í† ë§ˆí† ', 'tomato'],
    'ì‚¬ê³¼': [],  # ì‚¬ê³¼ëŠ” ì•Œë ˆë¥´ê¸° í‘œì‹œ ëŒ€ìƒ ì•„ë‹˜
}


def generate_food_label(slots, product_name="", volume_ml=500, bev_type=""):
    """ì‹í’ˆë“±ì˜ í‘œì‹œê¸°ì¤€ì— ë”°ë¥¸ ì „ì²´ í‘œì‹œì‚¬í•­ ìƒì„±"""
    active = [(s['ì›ë£Œëª…'], s['ë°°í•©ë¹„(%)']) for s in slots
              if safe_float(s.get('ë°°í•©ë¹„(%)', 0)) > 0 and s.get('ì›ë£Œëª…')]
    active.sort(key=lambda x: x[1], reverse=True)

    # 1. ì›ì¬ë£Œëª… (ë§ì´ ì‚¬ìš©í•œ ìˆœì„œ, 2% ë¯¸ë§Œì€ ìˆœì„œë¬´ê´€ ê°€ëŠ¥)
    over_2 = [(n, p) for n, p in active if p >= 2]
    under_2 = [(n, p) for n, p in active if p < 2]

    # 2. ì•Œë ˆë¥´ê¸° ìœ ë°œë¬¼ì§ˆ ê²€ì¶œ
    detected_allergens = []
    all_names = ' '.join([n for n, _ in active]).lower()
    for allergen, keywords in ALLERGEN_KEYWORDS.items():
        for kw in keywords:
            if kw in all_names:
                detected_allergens.append(allergen)
                break

    # 3. ì˜ì–‘ì„±ë¶„ (1íšŒ ì œê³µëŸ‰ + 100ml ê¸°ì¤€, 9ì¢… ì˜ë¬´í‘œì‹œ)
    total_sugar_g = 0
    for s in slots:
        p = safe_float(s.get('ë°°í•©ë¹„(%)', 0))
        bx = safe_float(s.get('Brix(Â°)', 0))
        if p > 0 and bx > 0:
            total_sugar_g += bx * p / 100 / 100 * 1000
    cal = total_sugar_g * 4
    serving = volume_ml  # 1íšŒ ì œê³µëŸ‰ = ì´ìš©ëŸ‰

    nutrition = {
        '1íšŒ ì œê³µëŸ‰': f'{serving}ml',
        'ì—´ëŸ‰': f'{cal/10*serving/100:.0f}kcal',
        'íƒ„ìˆ˜í™”ë¬¼': f'{total_sugar_g/10*serving/100:.1f}g',
        'ë‹¹ë¥˜': f'{total_sugar_g/10*serving/100:.1f}g',
        'ë‹¨ë°±ì§ˆ': '0g',
        'ì§€ë°©': '0g',
        'í¬í™”ì§€ë°©': '0g',
        'íŠ¸ëœìŠ¤ì§€ë°©': '0g',
        'ì½œë ˆìŠ¤í…Œë¡¤': '0mg',
        'ë‚˜íŠ¸ë¥¨': '5mg',  # ì¶”ì •
    }
    nutrition_100ml = {
        'ì—´ëŸ‰(100ml)': f'{cal/10:.1f}kcal',
        'ë‹¹ë¥˜(100ml)': f'{total_sugar_g/10:.1f}g',
    }

    # 4. ê¸°íƒ€ í‘œì‹œì‚¬í•­
    return {
        'â‘  ì œí’ˆëª…': product_name,
        'â‘¡ ì‹í’ˆìœ í˜•': bev_type,
        'â‘¢ ì—…ì†Œëª… ë° ì†Œì¬ì§€': '(ì œì¡°ì‚¬ ì •ë³´ ê¸°ì…)',
        'â‘£ ì†Œë¹„ê¸°í•œ': 'ì œì¡°ì¼ë¡œë¶€í„° â—‹â—‹ê°œì›” (ë³„ë„ ì„¤ì • í•„ìš”)',
        'â‘¤ ë‚´ìš©ëŸ‰': f'{volume_ml}ml',
        'â‘¥ ì›ì¬ë£Œëª…': ', '.join([n for n, _ in active]),
        'â‘¥-1 2%ì´ìƒ ì›ì¬ë£Œ': ', '.join([f'{n}({p:.1f}%)' for n, p in over_2]),
        'â‘¥-2 2%ë¯¸ë§Œ ì›ì¬ë£Œ': ', '.join([n for n, _ in under_2]) if under_2 else 'í•´ë‹¹ì—†ìŒ',
        'â‘¦ ì˜ì–‘ì„±ë¶„': nutrition,
        'â‘¦-1 100mlê¸°ì¤€': nutrition_100ml,
        'â‘§ ì•Œë ˆë¥´ê¸° ìœ ë°œë¬¼ì§ˆ': ', '.join(detected_allergens) + ' í•¨ìœ ' if detected_allergens else 'í•´ë‹¹ì—†ìŒ',
        'â‘¨ ë³´ê´€ë°©ë²•': 'ì§ì‚¬ê´‘ì„ ì„ í”¼í•´ ìƒì˜¨ë³´ê´€',
        'â‘© ì£¼ì˜ì‚¬í•­': 'ê°œë´‰ í›„ ëƒ‰ì¥ë³´ê´€í•˜ê³  ë¹ ë¥¸ ì‹œì¼ ë‚´ ë“œì‹œê¸° ë°”ëë‹ˆë‹¤.',
        'â‘ª í’ˆëª©ë³´ê³ ë²ˆí˜¸': '(ì‹ì•½ì²˜ í’ˆëª©ì œì¡°ë³´ê³  í›„ ê¸°ì…)',
        'â‘« ë°˜í’ˆ/êµí™˜': 'ê³µì •ê±°ë˜ìœ„ì›íšŒ ê³ ì‹œ ì†Œë¹„ìë¶„ìŸí•´ê²°ê¸°ì¤€ì— ì˜ê±° êµí™˜ ë˜ëŠ” ë³´ìƒ',
    }


# ============================================================
# 6. ì‹œì‘ë ˆì‹œí”¼
# ============================================================
def generate_lab_recipe(slots, scales=[1, 5, 20]):
    recipes = {}
    for sc in scales:
        total = sc * 1000
        items = []
        for s in slots:
            p = safe_float(s.get('ë°°í•©ë¹„(%)', 0))
            if p <= 0 or not s.get('ì›ë£Œëª…'):
                continue
            items.append({'ì›ë£Œëª…': s['ì›ë£Œëª…'], 'ë°°í•©ë¹„(%)': p, f'ì¹­ëŸ‰({sc}L)_g': round(p / 100 * total, 2)})
        recipes[f'{sc}L'] = items
    return recipes


# ============================================================
# 7. AI í˜ë¥´ì†Œë‚˜ë³„ í”„ë¡¬í”„íŠ¸
# ============================================================
PERSONA_RESEARCHER = """ë‹¹ì‹ ì€ ëŒ€í•œë¯¼êµ­ ìŒë£ŒíšŒì‚¬ 20ë…„ ê²½ë ¥ ìˆ˜ì„ ì—°êµ¬ì› "Dr. ì´ìŒë£Œ"ì…ë‹ˆë‹¤.
ë°°í•©í‘œë¥¼ ë°›ìœ¼ë©´ ë°˜ë“œì‹œ ì•„ë˜ë¥¼ í‰ê°€í•˜ì„¸ìš”:
1ï¸âƒ£ ê´€ëŠ¥ì˜ˆì¸¡: ì´ˆë‘ê°ë¯¸, ì¤‘ë¯¸, í›„ë¯¸, ë°”ë””ê°, í–¥ë¯¸ë°¸ëŸ°ìŠ¤
2ï¸âƒ£ ë°¸ëŸ°ìŠ¤ì§„ë‹¨: ë‹¹ì‚°ë¹„, ê°ë¯¸êµ¬ì¡°, ì‚°ë¯¸ìºë¦­í„°
3ï¸âƒ£ ê°œì„ ì œì•ˆ: êµ¬ì²´ì  ìˆ˜ì¹˜ë¡œ ("ì‚¬ê³¼ë†ì¶•ê³¼ì¦™ 8%â†’10%")
4ï¸âƒ£ ê¸°ìˆ íš¨ê³¼: ì•ˆì •ì„±, ì‚´ê· , ìœ í†µê¸°í•œ
5ï¸âƒ£ ìˆ˜ì •ë°°í•©í‘œ JSON: {"ìˆ˜ì •ë°°í•©": [{"ì›ë£Œëª…": "xxx", "ë°°í•©ë¹„(%)": 0.0}]}
í•œêµ­ì–´ ë‹µë³€. ì‹í’ˆê³µì „ ê·œê²© ê¸°ì¤€."""

PERSONA_PLANNER = """ë‹¹ì‹ ì€ ì‹í’ˆê¸°ì—… ì‹ ì œí’ˆê°œë°œíŒ€ 15ë…„ì°¨ R&D ì—°êµ¬ì›ì…ë‹ˆë‹¤.
ë°°í•©í‘œì™€ ê·œê²©ì„ ë°›ìœ¼ë©´:
1ï¸âƒ£ ì‹œì¥ì„± ë¶„ì„ (íƒ€ê²Ÿ ì†Œë¹„ì¸µ, í¬ì§€ì…”ë‹)
2ï¸âƒ£ í’ˆì§ˆê·œê²© ê²€í†  (ì‹í’ˆê³µì „ ì í•©ì„±)
3ï¸âƒ£ ì›ê°€ë¶„ì„ (ì¬ë£Œë¹„, í¬ì¥ë¹„, ì œì¡°ë¹„, ë§ˆì§„)
4ï¸âƒ£ ê²½ìŸì œí’ˆ ëŒ€ë¹„ ì°¨ë³„í™” í¬ì¸íŠ¸
5ï¸âƒ£ ì¶œì‹œ íƒ€ì„ë¼ì¸ ì œì•ˆ
í•œêµ­ì–´, í‘œ/í…Œì´ë¸” í˜•ì‹ ì ê·¹ í™œìš©."""

PERSONA_PRODUCTION = """ë‹¹ì‹ ì€ ìŒë£Œê³µì¥ 20ë…„ ê²½ë ¥ ìƒì‚°ê´€ë¦¬ìì…ë‹ˆë‹¤.
ë°°í•©í‘œì™€ ê³µì •ì„ ë°›ìœ¼ë©´:
1ï¸âƒ£ ê³µì •ë³„ íŒŒë¼ë¯¸í„° (ì˜¨ë„/ì‹œê°„/ì••ë ¥/êµë°˜ì†ë„)
2ï¸âƒ£ ë°°í•©ìˆœì„œ ë° íˆ¬ì… ì£¼ì˜ì‚¬í•­
3ï¸âƒ£ CCP ê´€ë¦¬ í¬ì¸íŠ¸ (ì‚´ê· , ì¶©ì „, ì´ë¬¼ê²€ì‚¬)
4ï¸âƒ£ ìƒì‚° ìˆ˜ìœ¨ ë° ë¡œìŠ¤ ì˜ˆìƒ
5ï¸âƒ£ ë°°ì¹˜ ê¸°ë¡ì„œ í…œí”Œë¦¿
í•œêµ­ì–´, ì‹¤ë¬´ ê´€ì ."""

PERSONA_QA = """ë‹¹ì‹ ì€ ì‹í’ˆ HACCP ì¸ì¦ì‹¬ì‚¬ì› ì¶œì‹  í’ˆì§ˆê´€ë¦¬ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.
ë°°í•©í‘œì™€ ê³µì •ì„ ë°›ìœ¼ë©´ ì‹ì•½ì²˜ í‘œì¤€ì–‘ì‹ì— ë”°ë¼:
1ï¸âƒ£ ìœ„í•´ë¶„ì„í‘œ (HA Worksheet) â€” ê³µì •ë³„ ìƒë¬¼/í™”í•™/ë¬¼ë¦¬ì  ìœ„í•´ìš”ì†Œ
2ï¸âƒ£ CCP ê²°ì •ë„ â€” Decision Tree (Q1~Q4)
3ï¸âƒ£ CCP ê´€ë¦¬ê³„íšì„œ â€” í•œê³„ê¸°ì¤€/ëª¨ë‹ˆí„°ë§/ê°œì„ ì¡°ì¹˜/ê²€ì¦/ê¸°ë¡
4ï¸âƒ£ ëª¨ë‹ˆí„°ë§ ì¼ì§€ ì–‘ì‹
5ï¸âƒ£ ê³µì •íë¦„ë„
í•œêµ­ì–´, ì‹ì•½ì²˜ HACCP í‘œì¤€ì–‘ì‹ ì¤€ìˆ˜."""

PERSONA_FORMULATOR = """ë‹¹ì‹ ì€ ìŒë£Œ ë°°í•©ì„¤ê³„ ì „ë¬¸ ì—°êµ¬ì›ì…ë‹ˆë‹¤.
ìŒë£Œìœ í˜•ê³¼ ë§›(Flavor)ì„ ë°›ìœ¼ë©´:
- í•´ë‹¹ ìœ í˜•+ë§›ì— ìµœì í™”ëœ ë°°í•©ë¹„ë¥¼ ì„¤ê³„í•˜ì„¸ìš”
- ì›ì¬ë£Œ, ë‹¹ë¥˜, ì‚°ë¯¸ë£Œ, ì•ˆì •ì œ, í–¥ë£Œ, ë¹„íƒ€ë¯¼ ë“± ëª¨ë“  ì¹´í…Œê³ ë¦¬ í¬í•¨
- ê° ì›ë£Œì˜ ë°°í•©ë¹„(%)ë¥¼ êµ¬ì²´ì ìœ¼ë¡œ ì œì‹œ
- ì •ì œìˆ˜ë¡œ 100% ë§ì¶”ê¸°
ë°˜ë“œì‹œ ì•„ë˜ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µ:
{"ë°°í•©": [{"ìŠ¬ë¡¯": 1, "ì›ë£Œëª…": "xxx", "ë°°í•©ë¹„": 0.0, "êµ¬ë¶„": "ì›ì¬ë£Œ"}, ...]}
"""

# [ê°œì„ 6] ë§ˆì¼€íŒ… ì»¨ì…‰ â†’ R&D ë°°í•©ì„¤ê³„ ë³€í™˜ í˜ë¥´ì†Œë‚˜
PERSONA_MARKETING_RD = """ë‹¹ì‹ ì€ ëŒ€í˜• ìŒë£ŒíšŒì‚¬ R&Dì„¼í„° 15ë…„ì°¨ ìŒë£Œì—°êµ¬ì›ì…ë‹ˆë‹¤.
ë§ˆì¼€íŒ…íŒ€ìœ¼ë¡œë¶€í„° ì‹ ì œí’ˆ ì»¨ì…‰ì„ ì „ë‹¬ë°›ì•„ ì‹¤í˜„ ê°€ëŠ¥í•œ ë°°í•©í‘œë¡œ ë³€í™˜í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ë§ˆì¼€íŒ… ì»¨ì…‰ì„ ë°›ìœ¼ë©´ ë°˜ë“œì‹œ:
1ï¸âƒ£ ì»¨ì…‰ë¶„ì„: íƒ€ê²Ÿ, í¬ì§€ì…”ë‹, í•µì‹¬ ê°€ì¹˜ë¥¼ íŒŒì•…
2ï¸âƒ£ ì‹í’ˆìœ í˜• ê²°ì •: ì–´ë–¤ ìŒë£Œ ì¹´í…Œê³ ë¦¬ê°€ ì í•©í•œì§€
3ï¸âƒ£ ë§›/í–¥ ì„¤ê³„: ì£¼ìš” í”Œë ˆì´ë²„ ë°©í–¥
4ï¸âƒ£ ë°°í•©í‘œ ì„¤ê³„: êµ¬ì²´ì  ì›ë£Œëª…ê³¼ ë°°í•©ë¹„(%)

ë°°í•©í‘œëŠ” ë°˜ë“œì‹œ ì•„ë˜ JSONìœ¼ë¡œ í¬í•¨:
```json
{"ìŒë£Œìœ í˜•": "ê³¼Â·ì±„ìŒë£Œ", "ë§›": "ì‚¬ê³¼", "ì»¨ì…‰ìš”ì•½": "...",
 "ì£¼ìš”ì›ë£Œì„¤ëª…": [{"ì›ë£Œëª…": "xxx", "ì‚¬ìš©ì´ìœ ": "..."}],
 "ë°°í•©": [{"ìŠ¬ë¡¯": 1, "ì›ë£Œëª…": "xxx", "ë°°í•©ë¹„": 0.0, "êµ¬ë¶„": "ì›ì¬ë£Œ", "ìš©ë„íŠ¹ì„±": "..."}]}
```
í•œêµ­ì–´. ì›ì¬ë£Œ(1-4), ë‹¹ë¥˜(5-8), ì•ˆì •ì œ(9-12), ê¸°íƒ€(13-19) ìˆœì„œ. ì •ì œìˆ˜ ì œì™¸."""


def call_gpt_ingredient_info(api_key, ingredient_name):
    """[ê°œì„ 2] AIê°€ ì›ë£Œì˜ ìš©ë„/íŠ¹ì„±ì„ í•œì¤„ë¡œ ì„¤ëª…"""
    from openai import OpenAI
    client = OpenAI(api_key=api_key)
    resp = client.chat.completions.create(
        model="gpt-4o-mini", temperature=0.3, max_tokens=60,
        messages=[
            {"role": "system", "content": "ì‹í’ˆì›ë£Œ ì „ë¬¸ê°€. ì›ë£Œì˜ ìŒë£Œì—ì„œì˜ ì‚¬ìš©ìš©ë„ì™€ íŠ¹ì„±ì„ 15ì ì´ë‚´ í•œì¤„ë¡œë§Œ ë‹µë³€."},
            {"role": "user", "content": f"ì›ë£Œ: {ingredient_name}"}
        ],
    )
    return resp.choices[0].message.content.strip()[:20]


def call_gpt_marketing_to_rd(api_key, concept_text, ing_sample=""):
    """[ê°œì„ 6] ë§ˆì¼€íŒ… ì»¨ì…‰ â†’ R&D ë°°í•©í‘œ ë³€í™˜"""
    content = f"""ë§ˆì¼€íŒ…íŒ€ ì»¨ì…‰:\n{concept_text}\n\nì‚¬ìš©ê°€ëŠ¥ ì›ë£ŒDB: {ing_sample[:500]}"""
    text = call_gpt(api_key, PERSONA_MARKETING_RD, content, model="gpt-4o", temp=0.6)
    # JSON ì¶”ì¶œ
    result = {'text': text, 'formulation': []}
    try:
        m = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
        if m:
            parsed = json.loads(m.group(1))
            result['formulation'] = parsed.get('ë°°í•©', [])
            result['bev_type'] = parsed.get('ìŒë£Œìœ í˜•', '')
            result['flavor'] = parsed.get('ë§›', '')
            result['summary'] = parsed.get('ì»¨ì…‰ìš”ì•½', '')
            result['ingredients_info'] = parsed.get('ì£¼ìš”ì›ë£Œì„¤ëª…', [])
    except:
        pass
    return result


# êµìœ¡ìš© ë‹¨ê³„ë³„ ì£¼ì˜ì‚¬í•­
EDUCATION_STEPS = {
    '1ë‹¨ê³„_ì›ì¬ë£Œ': {
        'icon': 'ğŸ', 'title': 'ì›ì¬ë£Œ íˆ¬ì…',
        'items': 'ê³¼ì¦™, ë†ì¶•ì•¡, í“¨ë ˆ ë“±',
        'guide': 'ê³¼ì¦™í•¨ëŸ‰ ê·œê²© ì¶©ì¡± í™•ì¸. ë†ì¶•ê³¼ì¦™ì€ í™˜ì›ë°°ìœ¨(BrixÃ·11.5) ê³ ë ¤. ì›ì‚°ì§€ í‘œì‹œ í•„ìˆ˜.',
        'warning': 'âš ï¸ ëƒ‰ì¥ì›ë£ŒëŠ” íˆ¬ì… ì „ í’ˆì˜¨ í™•ì¸(â‰¤10â„ƒ). ì´ë¬¼ì§ˆ ìœ¡ì•ˆê²€ì‚¬ í•„ìˆ˜.',
    },
    '2ë‹¨ê³„_ë‹¹ë¥˜': {
        'icon': 'ğŸ¯', 'title': 'ë‹¹ë¥˜/ê°ë¯¸ë£Œ íˆ¬ì…',
        'items': 'ì„¤íƒ•, ì•¡ìƒê³¼ë‹¹, ì˜¬ë¦¬ê³ ë‹¹, ê³ ê°ë¯¸ë£Œ ë“±',
        'guide': 'ëª©í‘œ Brixì— ë§ì¶° ì„¤íƒ• 1%â‰ˆBrix 1Â° ê¸°ì¤€. HFCSëŠ” 0.77Â°/%. ê³ ê°ë¯¸ë£ŒëŠ” ppm ë‹¨ìœ„ ì£¼ì˜.',
        'warning': 'âš ï¸ ì„¤íƒ•ì€ ì™„ì „ìš©í•´ í™•ì¸(êµë°˜ 60â„ƒâ†‘). ê³ ê°ë¯¸ë£ŒëŠ” ê³¼ëŸ‰íˆ¬ì… ì‹œ ì´ë¯¸(off-taste).',
    },
    '3ë‹¨ê³„_ì‚°ë¯¸ë£Œ': {
        'icon': 'ğŸ‹', 'title': 'ì‚°ë¯¸ë£Œ/pH ì¡°ì ˆ',
        'items': 'êµ¬ì—°ì‚°, ì‚¬ê³¼ì‚°, ë¹„íƒ€ë¯¼C ë“±',
        'guide': 'êµ¬ì—°ì‚° 0.1%â†’pHì•½ 0.1â†“. ì‚°ë„ì™€ pHëŠ” ë‹¤ë¥¸ ê°œë…. ë‹¹ì‚°ë¹„(Brix/ì‚°ë„) ëª©í‘œ í™•ì¸.',
        'warning': 'âš ï¸ ì‚°ë¯¸ë£Œ ê³¼ëŸ‰â†’ì¹˜ì•„ ì¹¨ì‹ ìš°ë ¤. pH 3.0 ë¯¸ë§Œ íšŒí”¼ ê¶Œì¥.',
    },
    '4ë‹¨ê³„_ì•ˆì •ì œ': {
        'icon': 'ğŸ§ª', 'title': 'ì•ˆì •ì œ/í˜¸ë£Œ íˆ¬ì…',
        'items': 'í™í‹´, CMC, ì”íƒ„ê²€, êµ¬ì•„ê²€ ë“±',
        'guide': 'ê³¼ì¦™ìŒë£ŒëŠ” HMí™í‹´ 0.1~0.3%. ìœ í™”ì œëŠ” ì˜¤ì¼ë¶„ì‚° ëª©ì . íˆ¬ì… ìˆœì„œ ì¤‘ìš”.',
        'warning': 'âš ï¸ ì•ˆì •ì œëŠ” ë¶„ì‚°íˆ¬ì…(ë”ìŠ¤íŒ… ë°©ì§€). ë¯¸ë¦¬ ì„¤íƒ•ê³¼ ê±´ì‹í˜¼í•© í›„ íˆ¬ì….',
    },
    '5ë‹¨ê³„_ê¸°íƒ€': {
        'icon': 'ğŸŒ¿', 'title': 'í–¥ë£Œ/ìƒ‰ì†Œ/ë¹„íƒ€ë¯¼ íˆ¬ì…',
        'items': 'í–¥ë£Œ, ìƒ‰ì†Œ, ë¹„íƒ€ë¯¼, ë³´ì¡´ë£Œ ë“±',
        'guide': 'í–¥ë£ŒëŠ” ì‚´ê·  ì „ íˆ¬ì…(ì—´ì•ˆì •í˜•) ë˜ëŠ” ë¬´ê· ì¶©ì „ ì‹œ íˆ¬ì…. ë¹„íƒ€ë¯¼CëŠ” ì‚°í™”ë°©ì§€+ì˜ì–‘ê°•í™” ê²¸ìš©.',
        'warning': 'âš ï¸ ì²œì—°í–¥ì€ ì—´ì— ì•½í•¨. ë³´ì¡´ë£ŒëŠ” ì‹í’ˆê³µì „ ê¸°ì¤€ ì´ˆê³¼ ê¸ˆì§€.',
    },
}

# HACCP ê³µì •ë³„ ì•„ì´ì½˜ ë§¤í•‘
HACCP_ICONS = {
    'ì…ê³ ': 'ğŸ“¦', 'ê²€ìˆ˜': 'ğŸ”', 'ì €ì¥': 'ğŸª', 'ë³´ê´€': 'ğŸª',
    'ì¹­ëŸ‰': 'âš–ï¸', 'ë°°í•©': 'ğŸ”¬', 'í˜¼í•©': 'ğŸŒ€', 'êµë°˜': 'ğŸŒ€',
    'ìš©í•´': 'ğŸ’§', 'ì—¬ê³¼': 'ğŸ”²', 'íƒˆê¸°': 'ğŸ’¨', 'ê· ì§ˆ': 'ğŸ”§',
    'ì‚´ê· ': 'ğŸ”¥', 'UHT': 'ğŸ”¥', 'ëƒ‰ê°': 'â„ï¸',
    'ì¶©ì „': 'ğŸ­', 'ë°€ë´‰': 'ğŸ”’', 'ê²€ì‚¬': 'ğŸ”', 'ê¸ˆì†': 'ğŸ§²',
    'í¬ì¥': 'ğŸ“¦', 'ì¶œí•˜': 'ğŸš›', 'ë¼ë²¨': 'ğŸ·ï¸',
    'ë°œíš¨': 'ğŸ¦ ', 'ìˆ™ì„±': 'â³', 'íƒ„ì‚°': 'ğŸ«§', 'ì¹´ë³´': 'ğŸ«§',
}


def call_gpt(api_key, system_prompt, user_content, model="gpt-4o", temp=0.7, max_tok=3000):
    from openai import OpenAI
    client = OpenAI(api_key=api_key)
    resp = client.chat.completions.create(
        model=model, temperature=temp, max_tokens=max_tok,
        messages=[{"role": "system", "content": system_prompt}, {"role": "user", "content": user_content}],
    )
    return resp.choices[0].message.content


def call_gpt_ai_formulation(api_key, bev_type, flavor, ing_names_sample=""):
    """AIê°€ ìœ í˜•+ë§›ì— ë§ëŠ” ë°°í•©ë¹„ ì¶”ì²œ"""
    content = f"""ìŒë£Œìœ í˜•: {bev_type}
ë§›(Flavor): {flavor}
ì‚¬ìš©ê°€ëŠ¥ ì›ë£ŒDB ìƒ˜í”Œ: {ing_names_sample[:500]}

ìœ„ ìœ í˜•ê³¼ ë§›ì— ìµœì í™”ëœ ë°°í•©ë¹„ë¥¼ JSONìœ¼ë¡œ ì„¤ê³„í•´ì£¼ì„¸ìš”.
ì›ì¬ë£Œ(1-4í–‰), ë‹¹ë¥˜/ê°ë¯¸ë£Œ(5-8í–‰), ì•ˆì •ì œ/í˜¸ë£Œ(9-12í–‰), ê¸°íƒ€ìì¬(13-19í–‰) ìˆœì„œ.
ì •ì œìˆ˜(20í–‰)ëŠ” ìë™ê³„ì‚°ë˜ë‹ˆ ì œì™¸."""
    text = call_gpt(api_key, PERSONA_FORMULATOR, content, model="gpt-4o", temp=0.5)
    try:
        m = re.search(r'\{[^{}]*"ë°°í•©"\s*:\s*\[.*?\]\s*\}', text, re.DOTALL)
        if m:
            return json.loads(m.group(0)).get('ë°°í•©', [])
    except:
        pass
    return []


def call_gpt_estimate_ingredient(api_key, ingredient_name, category=""):
    """ì§ì ‘ì…ë ¥ ì›ë£Œ ì´í™”í•™ê·œê²© AI ì¶”ì •"""
    prompt = f"""ì›ë£Œëª…: {ingredient_name}
ë¶„ë¥˜: {category}

ì¤‘ìš” ì°¸ê³ ê¸°ì¤€:
- ë†ì¶•ê³¼ì¦™: Brix 40~70Â°, pH 2.5~4.5, ì‚°ë„ 1~8%, ë‹¨ê°€ 3000~15000ì›/kg
  ì˜ˆ) ì˜¤ë Œì§€ë†ì¶•ê³¼ì¦™(65Brix): Brix=65, 1pct_Brixê¸°ì—¬=0.65
- ê³¼ì¼í“¨ë ˆ: Brix 8~15Â°, pH 3.0~4.5, ë‹¨ê°€ 2000~8000ì›/kg
- ë‹¹ë¥˜: Brix 65~100Â°, ê°ë¯¸ë„ 0.4~1.8
  ì˜ˆ) ì„¤íƒ•: Brix=100, ê°ë¯¸ë„=1.0, 1pct_Brixê¸°ì—¬=1.0, 1pct_ê°ë¯¸ê¸°ì—¬=0.01
  ì˜ˆ) ì•¡ìƒê³¼ë‹¹(HFCS55): Brix=77, ê°ë¯¸ë„=1.1, 1pct_Brixê¸°ì—¬=0.77
- ê³ ê°ë¯¸ë£Œ: ê°ë¯¸ë„ 100~600, ì˜ˆ) ìˆ˜í¬ë„ë¡œìŠ¤: ê°ë¯¸ë„=600, 1pct_ê°ë¯¸ê¸°ì—¬=6.0
- ì‚°ë¯¸ë£Œ: 1pct_pHì˜í–¥ ìŒìˆ˜, ì˜ˆ) êµ¬ì—°ì‚°: 1pct_pHì˜í–¥=-0.40

1pct_Brixê¸°ì—¬ = Brix / 100
1pct_ê°ë¯¸ê¸°ì—¬ = ê°ë¯¸ë„_ì„¤íƒ•ëŒ€ë¹„ / 100
â˜… ë†ì¶•ì•¡/í“¨ë ˆ/ë‹¹ë¥˜/ì‹œëŸ½ì˜ Brixì™€ ê°ë¯¸ë„ëŠ” ë°˜ë“œì‹œ 0ë³´ë‹¤ ì»¤ì•¼ í•¨!

JSONë§Œ ì‘ë‹µ:
{{"Brix": 0, "pH": 0, "ì‚°ë„_pct": 0, "ê°ë¯¸ë„_ì„¤íƒ•ëŒ€ë¹„": 0, "ì˜ˆìƒë‹¨ê°€_ì›kg": 0, "1pct_Brixê¸°ì—¬": 0, "1pct_pHì˜í–¥": 0, "1pct_ì‚°ë„ê¸°ì—¬": 0, "1pct_ê°ë¯¸ê¸°ì—¬": 0}}"""

    from openai import OpenAI
    client = OpenAI(api_key=api_key)
    resp = client.chat.completions.create(
        model="gpt-4o-mini", temperature=0.3, max_tokens=300,
        messages=[
            {"role": "system", "content": "ì‹í’ˆì›ë£Œ ì´í™”í•™ ë°ì´í„° ì „ë¬¸ê°€. JSONë§Œ ì‘ë‹µ."},
            {"role": "user", "content": prompt}
        ],
    )
    text = resp.choices[0].message.content.strip()
    text = re.sub(r'```json\s*', '', text)
    text = re.sub(r'```', '', text)
    return json.loads(text)


def call_dalle(api_key, prompt):
    from openai import OpenAI
    client = OpenAI(api_key=api_key)
    resp = client.images.generate(model="dall-e-3", prompt=prompt, size="1024x1024", quality="standard", n=1)
    return resp.data[0].url


def build_dalle_prompt(product_name, bev_type, slots, container="PET", volume=500):
    color_map = {'ì˜¤ë Œì§€': 'ì˜¤ë Œì§€ìƒ‰', 'ìëª½': 'í•‘í¬ìƒ‰', 'ë ˆëª¬': 'ë…¸ë€ìƒ‰', 'ë¼ì„': 'ì—°ë‘ìƒ‰',
                 'ë§ê³ ': 'í™©ê¸ˆìƒ‰', 'ì‚¬ê³¼': 'ë¶‰ì€+ì—°ë‘', 'ë³µìˆ­ì•„': 'ë¶„í™ìƒ‰', 'í¬ë„': 'ë³´ë¼ìƒ‰',
                 'ë¸”ë£¨ë² ë¦¬': 'ë‚¨ë³´ë¼', 'ë”¸ê¸°': 'ë¹¨ê°„ìƒ‰', 'ì„ë¥˜': 'ë£¨ë¹„ìƒ‰', 'ì»¤í”¼': 'ê°ˆìƒ‰'}
    color = 'íˆ¬ëª…'
    for s in slots:
        for k, c in color_map.items():
            if k in str(s.get('ì›ë£Œëª…', '')):
                color = c; break
    mains = [s['ì›ë£Œëª…'].split('(')[0] for s in slots if safe_float(s.get('ë°°í•©ë¹„(%)', 0)) > 0 and s['ì›ë£Œëª…'] != 'ì •ì œìˆ˜'][:3]
    return f"í•œêµ­ í¸ì˜ì  ìŒë£Œ íŒ¨í‚¤ì§€ ë””ìì¸. ì œí’ˆëª…:{product_name}, {bev_type}, ì£¼ì¬ë£Œ:{','.join(mains)}, ìƒ‰ìƒ:{color}, {container} {volume}ml, í¬í† ë¦¬ì–¼ë¦¬ìŠ¤í‹±"


def parse_modified_formulation(text):
    try:
        m = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
        if m:
            return json.loads(m.group(1)).get('ìˆ˜ì •ë°°í•©', [])
        m = re.search(r'\{"ìˆ˜ì •ë°°í•©":\s*\[.*?\]\}', text, re.DOTALL)
        if m:
            return json.loads(m.group(0)).get('ìˆ˜ì •ë°°í•©', [])
    except:
        pass
    return []


# ============================================================
# 8. HACCP ì„œë¥˜ 6ì¢… (ì‹ì•½ì²˜ í‘œì¤€ì–‘ì‹)
# ============================================================
# ê³µì •ë‹¨ê³„ë³„ ì•„ì´ì½˜
_STEP_ICONS = {
    'ì›ë£Œì…ê³ ': 'ğŸ“¦', 'ì…ê³ ': 'ğŸ“¦', 'ì›ë£Œê²€ìˆ˜': 'ğŸ”', 'ê²€ìˆ˜': 'ğŸ”',
    'ì¹­ëŸ‰': 'âš–ï¸', 'ê³„ëŸ‰': 'âš–ï¸', 'ìš©í•´': 'ğŸ”¥', 'í˜¼í•©': 'ğŸ”„', 'ë°°í•©': 'ğŸ”„', 'êµë°˜': 'ğŸ”„',
    'ê· ì§ˆ': 'ğŸŒ€', 'íƒˆê¸°': 'ğŸ’¨', 'ì‚´ê· ': 'ğŸ”¥', 'UHT': 'ğŸ”¥', 'ì—´ì²˜ë¦¬': 'ğŸ”¥',
    'ëƒ‰ê°': 'â„ï¸', 'ì¶©ì „': 'ğŸ­', 'ë°€ë´‰': 'ğŸ”’', 'í¬ì¥': 'ğŸ“¦', 'ë¼ë²¨ë§': 'ğŸ·ï¸',
    'ê²€ì‚¬': 'âœ…', 'ê²€ì¶œ': 'ğŸ”', 'ê¸ˆì†': 'ğŸ”', 'ì™„ì œí’ˆ': 'âœ…',
    'ë³´ê´€': 'ğŸª', 'ì¶œí•˜': 'ğŸš›', 'ë°œíš¨': 'ğŸ§«', 'ìˆ™ì„±': 'â°',
    'íƒ„ì‚°': 'ğŸ«§', 'ì¹´ë³´ë„¤ì´ì…˜': 'ğŸ«§', 'ì‹œëŸ½': 'ğŸ¯',
}


def get_step_icon(step_name):
    for keyword, icon in _STEP_ICONS.items():
        if keyword in str(step_name):
            return icon
    return 'âš™ï¸'
_PROCESS_MAP = {
    'ê³¼Â·ì±„ìŒë£Œ': 'ê³¼Â·ì±„ì£¼ìŠ¤', 'ê³¼Â·ì±„ì£¼ìŠ¤(100%)': 'ê³¼Â·ì±„ì£¼ìŠ¤', 'ê³¼Â·ì±„ì£¼ìŠ¤': 'ê³¼Â·ì±„ì£¼ìŠ¤',
    'íƒ„ì‚°ìˆ˜': 'íƒ„ì‚°ìŒë£Œ', 'íƒ„ì‚°ìŒë£Œ': 'íƒ„ì‚°ìŒë£Œ',
    'ì»¤í”¼ìŒë£Œ(ê°€ë‹¹)': 'ì»¤í”¼ìŒë£Œ', 'ì»¤í”¼ìŒë£Œ(ë¸”ë™)': 'ì»¤í”¼ìŒë£Œ', 'ì»¤í”¼ìŒë£Œ': 'ì»¤í”¼ìŒë£Œ',
    'ìœ ì‚°ê· ìŒë£Œ(ë¹„ì‚´ê· )': 'ìœ ì‚°ê· ìŒë£Œ', 'ìœ ì‚°ê· ìŒë£Œ(ì‚´ê· )': 'ìœ ì‚°ê· ìŒë£Œ', 'ìœ ì‚°ê· ìŒë£Œ': 'ìœ ì‚°ê· ìŒë£Œ',
    'ì ¤ë¦¬ìŒë£Œ': 'ì ¤ë¦¬ìŒë£Œ',
    'ì¹¨ì¶œì°¨/ì•¡ìƒì°¨': 'ê³¼Â·ì±„ì£¼ìŠ¤', 'ë‘ìœ ': 'ìœ ì‚°ê· ìŒë£Œ',
    'ì—ë„ˆì§€ìŒë£Œ': 'íƒ„ì‚°ìŒë£Œ', 'ì´ì˜¨ìŒë£Œ': 'ê³¼Â·ì±„ì£¼ìŠ¤', 'ë¹„íƒ€ë¯¼ìŒë£Œ': 'ê³¼Â·ì±„ì£¼ìŠ¤',
    'í˜¼í•©ìŒë£Œ': 'ê³¼Â·ì±„ì£¼ìŠ¤', 'í™ì‚¼ìŒë£Œ': 'ê³¼Â·ì±„ì£¼ìŠ¤', 'ì‹í˜œ': 'ê³¼Â·ì±„ì£¼ìŠ¤',
}


def match_process(bev_type, df_proc):
    """ê·œê²©DB ìŒë£Œìœ í˜• â†’ ê³µì •DB ë§¤ì¹­ (í´ë°± í¬í•¨)"""
    bt = bev_type.split('(')[0]
    # 1ì°¨: ì§ì ‘ ë§¤ì¹­
    m = df_proc[df_proc['ìŒë£Œìœ í˜•'].str.contains(bt, na=False)]
    if not m.empty:
        return m
    # 2ì°¨: ë§¤í•‘ í…Œì´ë¸”
    mapped = _PROCESS_MAP.get(bev_type) or _PROCESS_MAP.get(bt)
    if mapped:
        m = df_proc[df_proc['ìŒë£Œìœ í˜•'].str.contains(mapped, na=False)]
        if not m.empty:
            return m
    # 3ì°¨: ê³¼Â·ì±„ì£¼ìŠ¤ í´ë°± (ê°€ì¥ ë²”ìš©ì )
    return df_proc[df_proc['ìŒë£Œìœ í˜•'].str.contains('ê³¼Â·ì±„ì£¼ìŠ¤', na=False)]
def haccp_ha_worksheet(bev_type, df_proc):
    """ìœ„í•´ë¶„ì„í‘œ"""
    m = match_process(bev_type, df_proc)
    if m.empty:
        return "í•´ë‹¹ ìŒë£Œìœ í˜•ì˜ ê³µì • ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."
    lines = [
        "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”",
        "â”‚                    ìœ„í•´ë¶„ì„ ì‘ì—…ì¥ (HA Worksheet)                        â”‚",
        f"â”‚  ì œí’ˆìœ í˜•: {bev_type:<30}  ì‘ì„±ì¼: {datetime.now().strftime('%Y.%m.%d')}       â”‚",
        "â”œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤",
        "â”‚ No â”‚   ê³µì •ë‹¨ê³„   â”‚    ìœ„í•´ìš”ì†Œ      â”‚   ë°œìƒì›ì¸    â”‚ ì‹¬ê°ì„± â”‚  ì˜ˆë°©ì¡°ì¹˜    â”‚",
        "â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"]
    for i, (_, p) in enumerate(m.iterrows(), 1):
        step = str(p.get('ì„¸ë¶€ê³µì •', '-'))[:12]
        hazard = str(p.get('HACCP ìœ„í•´ìš”ì†Œ', '-')).replace('\n', ',')[:17]
        cause = str(p.get('í’ˆì§ˆê´€ë¦¬í¬ì¸íŠ¸', '-'))[:14]
        ccp_raw = str(p.get('CCPì—¬ë¶€', ''))
        ccp = f'â˜…{ccp_raw}' if ccp_raw.startswith('CCP') else '  -  '
        prev = str(p.get('ëª¨ë‹ˆí„°ë§ë°©ë²•', '-'))[:13]
        lines.append(f"â”‚ {i:2d} â”‚ {step:<12}â”‚ {hazard:<17}â”‚ {cause:<14}â”‚ {ccp:^8}â”‚ {prev:<13}â”‚")
    lines.append("â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    return '\n'.join(lines)


def haccp_ccp_decision_tree(bev_type, df_proc):
    """CCP ê²°ì •ë„"""
    m = match_process(bev_type, df_proc)
    if m.empty:
        return "í•´ë‹¹ ìŒë£Œìœ í˜•ì˜ ê³µì • ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."
    lines = [
        "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”",
        "â”‚                  CCP ê²°ì •ë„ (Decision Tree)                          â”‚",
        f"â”‚  ì œí’ˆìœ í˜•: {bev_type:<30}  ì‘ì„±ì¼: {datetime.now().strftime('%Y.%m.%d')}    â”‚",
        "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤",
        "â”‚  ê³µì •ë‹¨ê³„   â”‚Q1:ì˜ˆë°©ì¡°ì¹˜â”‚Q2:ì œê±°/ì €ê°â”‚Q3:ì˜¤ì—¼ì¦ê°€â”‚Q4:í›„ì†ì œê±°â”‚  CCPíŒì •   â”‚",
        "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"]
    for _, p in m.iterrows():
        step = str(p.get('ì„¸ë¶€ê³µì •', '-'))[:12]
        is_ccp = str(p.get('CCPì—¬ë¶€', '')).startswith('CCP')
        if is_ccp:
            lines.append(f"â”‚ {step:<12}â”‚   ì˜ˆ     â”‚   ì˜ˆ     â”‚    -     â”‚    -     â”‚  â˜… {p.get('CCPì—¬ë¶€','')}   â”‚")
        else:
            lines.append(f"â”‚ {step:<12}â”‚   ì˜ˆ     â”‚  ì•„ë‹ˆì˜¤  â”‚  ì•„ë‹ˆì˜¤  â”‚    -     â”‚   ë¹„CCP    â”‚")
    lines.append("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    return '\n'.join(lines)


def haccp_ccp_plan(bev_type, df_proc):
    """CCP ê´€ë¦¬ê³„íšì„œ"""
    m = match_process(bev_type, df_proc)
    ccp_rows = m[m['CCPì—¬ë¶€'].astype(str).str.startswith('CCP')]
    if ccp_rows.empty:
        return "CCP ê³µì •ì´ ì—†ìŠµë‹ˆë‹¤."
    lines = [
        "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”",
        "â”‚                   HACCP ê´€ë¦¬ê³„íšì„œ (HACCP Plan)                       â”‚",
        f"â”‚  ì œí’ˆìœ í˜•: {bev_type:<30}  ì‘ì„±ì¼: {datetime.now().strftime('%Y.%m.%d')}    â”‚",
        "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"]
    for _, p in ccp_rows.iterrows():
        ccp_no = p.get('CCPì—¬ë¶€', '')
        lines.extend([
            f"\nâ–  {ccp_no} â€” {p.get('ì„¸ë¶€ê³µì •', '')}",
            "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”",
            f"â”‚  ê³µì •ë‹¨ê³„     â”‚ {str(p.get('ê³µì •ë‹¨ê³„', '')):<48}â”‚",
            f"â”‚  ìœ„í•´ìš”ì†Œ     â”‚ {str(p.get('HACCP ìœ„í•´ìš”ì†Œ', '')).replace(chr(10), ', ')[:48]:<48}â”‚",
            f"â”‚  í•œê³„ê¸°ì¤€(CL) â”‚ {str(p.get('í•œê³„ê¸°ì¤€(CL)', ''))[:48]:<48}â”‚",
            f"â”‚  ëª¨ë‹ˆí„°ë§ë°©ë²• â”‚ {str(p.get('ëª¨ë‹ˆí„°ë§ë°©ë²•', ''))[:48]:<48}â”‚",
            f"â”‚  ëª¨ë‹ˆí„°ë§ì£¼ê¸° â”‚ {'ë§¤ ë°°ì¹˜':<48}â”‚",
            f"â”‚  ê°œì„ ì¡°ì¹˜     â”‚ {str(p.get('ê°œì„ ì¡°ì¹˜', ''))[:48]:<48}â”‚",
            f"â”‚  ê²€ì¦ë°©ë²•     â”‚ {'ê¸°ë¡ ê²€í†  ë° ì •ê¸° ê²€êµì •':<48}â”‚",
            f"â”‚  ê¸°ë¡ë¬¸ì„œ     â”‚ {'CCP ëª¨ë‹ˆí„°ë§ ì¼ì§€':<48}â”‚",
            "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"])
    return '\n'.join(lines)


def haccp_monitoring_log(bev_type, df_proc):
    """CCP ëª¨ë‹ˆí„°ë§ ì¼ì§€ (ë¹ˆ ì–‘ì‹)"""
    m = match_process(bev_type, df_proc)
    ccp_rows = m[m['CCPì—¬ë¶€'].astype(str).str.startswith('CCP')]
    if ccp_rows.empty:
        return "CCP ê³µì •ì´ ì—†ìŠµë‹ˆë‹¤."
    lines = [
        "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”",
        "â”‚                    CCP ëª¨ë‹ˆí„°ë§ ì¼ì§€                                  â”‚",
        f"â”‚  ì œí’ˆìœ í˜•: {bev_type:<30}  ì‘ì„±ì¼ì: ____ë…„ ____ì›” ____ì¼       â”‚",
        "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"]
    for _, p in ccp_rows.iterrows():
        lines.extend([
            f"\nâ–  {p.get('CCPì—¬ë¶€', '')} â€” {p.get('ì„¸ë¶€ê³µì •', '')}",
            f"  í•œê³„ê¸°ì¤€: {p.get('í•œê³„ê¸°ì¤€(CL)', '')}",
            "â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”",
            "â”‚ ì‹œê°„  â”‚   ì¸¡ì •ê°’    â”‚ ì í•©ì—¬ë¶€â”‚   ì´íƒˆì‹œì¡°ì¹˜  â”‚ ë‹´ë‹¹ìâ”‚ í™•ì¸ìâ”‚",
            "â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤"])
        for _ in range(8):
            lines.append("â”‚__:__ â”‚____________â”‚ â–¡ì í•©   â”‚______________â”‚______â”‚______â”‚")
        lines.append("â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜")
    lines.extend([
        "\nâ€» ì´íƒˆ ë°œìƒ ì‹œ ì¦‰ì‹œ ê°œì„ ì¡°ì¹˜ í›„ HACCPíŒ€ì¥ ë³´ê³ ",
        "  ë‹´ë‹¹ì: ________  í™•ì¸ì: ________  HACCPíŒ€ì¥: ________"])
    return '\n'.join(lines)


def haccp_flow_diagram(bev_type, df_proc):
    """ê³µì •íë¦„ë„"""
    m = match_process(bev_type, df_proc)
    if m.empty:
        return "í•´ë‹¹ ìŒë£Œìœ í˜•ì˜ ê³µì • ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."
    lines = [f"ê³µì •íë¦„ë„ â€” {bev_type}", "=" * 50]
    prev = False
    for _, p in m.iterrows():
        step = p.get('ì„¸ë¶€ê³µì •', '')
        icon = get_step_icon(step)
        ccp_raw = str(p.get('CCPì—¬ë¶€', ''))
        ccp = f" â˜…{ccp_raw}" if ccp_raw.startswith('CCP') else ""
        cond = str(p.get('ì£¼ìš”ì¡°ê±´/íŒŒë¼ë¯¸í„°', ''))[:35]
        if prev:
            lines.extend(["        â”‚", "        â–¼"])
        lines.extend([
            "  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”",
            f"  â”‚ {icon} {step}{ccp:<25}â”‚",
            f"  â”‚    {cond:<29}â”‚",
            "  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"])
        prev = True
    return '\n'.join(lines)


def haccp_sop(bev_type, df_proc, product_name="", slots=None):
    """ì‘ì—…í‘œì¤€ì„œ (SOP)"""
    m = match_process(bev_type, df_proc)
    if m.empty:
        return "í•´ë‹¹ ìŒë£Œìœ í˜•ì˜ ê³µì • ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."
    lines = [
        "=" * 70,
        f"  ì‘ì—…í‘œì¤€ì„œ (Standard Operating Procedure)",
        f"  ì œí’ˆëª…: {product_name}  |  ìœ í˜•: {bev_type}",
        f"  ì‘ì„±ì¼: {datetime.now().strftime('%Y.%m.%d')}  |  ê°œì •: Rev.01",
        "=" * 70]
    if slots:
        lines.append("\nâ–  ë°°í•©í‘œ")
        lines.append(f"  {'No':<4} {'ì›ë£Œëª…':<25} {'ë°°í•©ë¹„(%)':<10} {'ì¹­ëŸ‰(g/kg)':<12}")
        lines.append("  " + "-" * 55)
        for i, s in enumerate(slots):
            if safe_float(s.get('ë°°í•©ë¹„(%)', 0)) > 0 and s.get('ì›ë£Œëª…'):
                lines.append(f"  {i+1:<4} {s['ì›ë£Œëª…']:<25} {s['ë°°í•©ë¹„(%)']:<10.3f} {safe_float(s.get('ë°°í•©ëŸ‰(g/kg)', 0)):<12.1f}")
    for _, p in m.iterrows():
        ccp_raw = str(p.get('CCPì—¬ë¶€', ''))
        ccp = f" [{ccp_raw}]" if ccp_raw.startswith('CCP') else ""
        icon = get_step_icon(str(p.get('ì„¸ë¶€ê³µì •', '')))
        lines.extend([
            f"\n{'â”€'*70}",
            f"â–  {icon} {p.get('ê³µì •ë‹¨ê³„', '')} â€” {p.get('ì„¸ë¶€ê³µì •', '')}{ccp}",
            f"{'â”€'*70}",
            f"  ã€ì‘ì—…ë°©ë²•ã€‘ {p.get('ì‘ì—…ë°©ë²•(êµ¬ì²´ì )', '-')}",
            f"  ã€ì¡°ê±´/íŒŒë¼ë¯¸í„°ã€‘ {p.get('ì£¼ìš”ì¡°ê±´/íŒŒë¼ë¯¸í„°', '-')}",
            f"  ã€í’ˆì§ˆê´€ë¦¬ã€‘ {p.get('í’ˆì§ˆê´€ë¦¬í¬ì¸íŠ¸', '-')}"])
        if ccp:
            lines.extend([
                f"  ã€â˜…HACCPã€‘ ìœ„í•´ìš”ì†Œ: {str(p.get('HACCP ìœ„í•´ìš”ì†Œ', '')).replace(chr(10), ', ')}",
                f"            í•œê³„ê¸°ì¤€: {p.get('í•œê³„ê¸°ì¤€(CL)', '-')}",
                f"            ëª¨ë‹ˆí„°ë§: {p.get('ëª¨ë‹ˆí„°ë§ë°©ë²•', '-')}",
                f"            ê°œì„ ì¡°ì¹˜: {p.get('ê°œì„ ì¡°ì¹˜', '-')}"])
    lines.extend(["", "=" * 70, "  ì‘ì„±:________  ê²€í† :________  ìŠ¹ì¸:________"])
    return '\n'.join(lines)
